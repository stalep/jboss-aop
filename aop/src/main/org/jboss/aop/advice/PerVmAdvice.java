/*
  * JBoss, Home of Professional Open Source
  * Copyright 2005, JBoss Inc., and individual contributors as indicated
  * by the @authors tag. See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it
  * under the terms of the GNU Lesser General Public License as
  * published by the Free Software Foundation; either version 2.1 of
  * the License, or (at your option) any later version.
  *
  * This software is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with this software; if not, write to the Free
  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
  */
package org.jboss.aop.advice;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.security.ProtectionDomain;
import java.util.ArrayList;

import javassist.CannotCompileException;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtField;
import javassist.CtMethod;
import javassist.CtNewMethod;

import org.jboss.aop.AspectManager;
import org.jboss.aop.instrument.OptimizedMethodInvocations;
import org.jboss.aop.instrument.TransformerCommon;
import org.jboss.aop.joinpoint.Invocation;
import org.jboss.aop.joinpoint.Joinpoint;
import org.jboss.aop.joinpoint.MethodInvocation;
import org.jboss.aop.joinpoint.MethodJoinpoint;
import org.jboss.aop.util.ReflectToJavassist;
import org.jboss.aop.util.logging.AOPLogger;
import org.jboss.logging.Logger;

/**
 * Comment
 *
 * @author <a href="mailto:bill@jboss.org">Bill Burke</a>
 * @version $Revision$
 */
public class PerVmAdvice
{
   private static final Logger logger = AOPLogger.getLogger(PerVmAdvice.class);
   
   private static long counter = 0;

   public static synchronized Interceptor generateOptimized(Joinpoint joinpoint, AspectManager manager, String adviceName, AspectDefinition a) throws Exception
   {
      Object aspect = manager.getPerVMAspect(a);
      return generateInterceptor(joinpoint, aspect, adviceName);

   }

   public static Interceptor generateInterceptor(Joinpoint joinpoint, Object aspect, String adviceName) throws Exception
   {
      ClassLoader cl = aspect.getClass().getClassLoader();
      String name = "org.jboss.aop.advice." + aspect.getClass().getName() + "_z_" + adviceName + "_" + System.identityHashCode(cl);
      Class iclass = null;

      if (cl == null)
      {
         //The classloader will be null if loader by the booststrap classloader
         cl = Thread.currentThread().getContextClassLoader();
      }
      synchronized (PerVmAdvice.class)
      {
         try
         {
            iclass = cl.loadClass(name);
         }
         catch(Exception e)
         {
         }

         ClassPool pool;
         try
         {
            pool = AspectManager.instance().findClassPool(cl);
         }
         catch (RuntimeException e)
         {
            // AutoGenerated
            throw new RuntimeException(e);
         }

         if (iclass == null)
         {
            //Aspects deployed in the lib folder, such as the AOP/MC integration aspects like the JMXIntroduction
            //will be deployed in the root classloader, but created in a pool for a child ucl due to the nature of AspectManager.findClassPool()
            try
            {
               ClassLoader pcl = pool.getClassLoader();
               iclass = pcl.loadClass(name);
            }
            catch(Exception e)
            {
            }
         }

         if (iclass == null)
         {
            Method[] methods = aspect.getClass().getMethods();
            ArrayList matches = new ArrayList();
            for (int i = 0; i < methods.length; i++)
            {
               if (methods[i].getName().equals(adviceName)) matches.add(methods[i]);
            }
            if(matches.size() == 0)
               throw new RuntimeException("Class "+aspect.getClass()+" didnt include any method called "+adviceName+", no interceptor will be created.");

            // TODO Need to have checks on whether the advice is overloaded and it is an argument type interception
            if (matches.size() == 1)
            {
               Method method = (Method) matches.get(0);
               if (joinpoint instanceof MethodJoinpoint)
               {
                  if (method.getParameterTypes().length == 0 || method.getParameterTypes().length > 1 || !Invocation.class.isAssignableFrom(method.getParameterTypes()[0]))
                  {
                     return generateArgsInterceptor(aspect, method, joinpoint);
                  }
               }
            }

//            ClassPool pool = AspectManager.instance().findClassPool(cl);
            CtClass clazz = TransformerCommon.makeClass(pool, name);

            // We need to know whether this Interceptor is actually advice.
            CtClass interceptorInterface = pool.get("org.jboss.aop.advice.Interceptor");
            CtClass abstractAdviceClass = pool.get("org.jboss.aop.advice.AbstractAdvice");
            clazz.setSuperclass(abstractAdviceClass);

            // aspect field
            CtClass aspectClass = pool.get(aspect.getClass().getName());
            CtField field = new CtField(aspectClass, "aspectField", clazz);
            field.setModifiers(javassist.Modifier.PUBLIC);
            clazz.addField(field);
            // getName()
            CtMethod getNameTemplate = interceptorInterface.getDeclaredMethod("getName");
            String getNameBody =
            "{ " +
            "   return \"" + aspect.getClass().getName() + "." + adviceName + "\"; " +
            "}";
            CtMethod getName = CtNewMethod.make(getNameTemplate.getReturnType(), "getName", getNameTemplate.getParameterTypes(), getNameTemplate.getExceptionTypes(), getNameBody, clazz);
            getName.setModifiers(javassist.Modifier.PUBLIC);
            clazz.addMethod(getName);

            // invoke
            CtMethod invokeTemplate = interceptorInterface.getDeclaredMethod("invoke");
            StringBuffer invokeBody = new StringBuffer();
            invokeBody.append("{  ");
            if (matches.size() > 1)
            {
               boolean noArg = false;
               for (int i = 0; i < matches.size(); i++)
               {
                  Method advice = (Method) matches.get(i);
                  if (advice.getParameterTypes().length > 0)
                  {
                     String param = advice.getParameterTypes()[0].getName();
                     invokeBody.append("   if ($1 instanceof " + param + ") return aspectField." + adviceName + "((" + param + ")$1); ");
                  }
                  else
                  {
                     noArg = true;
                     invokeBody.append("   return aspectField." + adviceName + "(); ");
                     break;
                  }
               }
               if (!noArg)
               invokeBody.append("   return (org.jboss.aop.joinpoint.Invocation)null; ");
            }
            else
            {
               Method advice = (Method) matches.get(0);
               String param = advice.getParameterTypes()[0].getName();
               invokeBody.append("return aspectField." + adviceName + "((" + param + ")$1); ");
            }
            invokeBody.append("}");
            CtMethod invoke = CtNewMethod.make(invokeTemplate.getReturnType(), "invoke", invokeTemplate.getParameterTypes(), invokeTemplate.getExceptionTypes(), invokeBody.toString(), clazz);
            invoke.setModifiers(javassist.Modifier.PUBLIC);
            clazz.addMethod(invoke);

            ProtectionDomain pd = aspect.getClass().getProtectionDomain();
            iclass = TransformerCommon.toClass(clazz, cl, pd);
         }
      }
      Interceptor rtn = (Interceptor) iclass.newInstance();
      Field f = iclass.getField("aspectField");
      f.set(rtn, aspect);
      return rtn;
   }

   public static Interceptor generateArgsInterceptor(Object aspect, Method advice, Joinpoint joinpoint) throws Exception
   {
      

      ClassPool pool = AspectManager.instance().findClassPool(aspect.getClass().getClassLoader());
      CtClass clazz = TransformerCommon.makeClass(pool, "org.jboss.aop.advice." + aspect.getClass().getName() + counter++);

      // We need to know whether this Interceptor is actually advice.
      CtClass interceptorInterface = pool.get("org.jboss.aop.advice.Interceptor");
      clazz.addInterface(interceptorInterface);

      // aspect field
      CtClass aspectClass = pool.get(aspect.getClass().getName());
      CtField field = new CtField(aspectClass, "aspectField", clazz);
      field.setModifiers(javassist.Modifier.PUBLIC);
      clazz.addField(field);
      // getName()
      CtMethod getNameTemplate = interceptorInterface.getDeclaredMethod("getName");
      String getNameBody =
      "{ " +
      "   return \"" + aspect.getClass().getName() + "." + advice.getName() + "\"; " +
      "}";
      CtMethod getName = CtNewMethod.make(getNameTemplate.getReturnType(), "getName", getNameTemplate.getParameterTypes(), getNameTemplate.getExceptionTypes(), getNameBody, clazz);
      getName.setModifiers(javassist.Modifier.PUBLIC);
      clazz.addMethod(getName);

      // invoke
      Method method = ((MethodJoinpoint) joinpoint).getMethod();
      String invocationType = null;
      if (AspectManager.optimize)
      {
         invocationType =   OptimizedMethodInvocations.getOptimizedInvocationClassName(method);
      }
      else
      {
         invocationType = MethodInvocation.class.getName();
      }
      
      StringBuffer invokeBody = new StringBuffer("public Object invoke(org.jboss.aop.joinpoint.Invocation invocation) throws java.lang.Throwable ");
      invokeBody.append("{     ").append(invocationType).append(" typedInvocation = (");
      invokeBody.append(invocationType).append(")invocation; ");
      if (!AspectManager.optimize)
      {
         invokeBody.append("   Object[] arguments = typedInvocation.getArguments();");
      }
      if (advice.getParameterTypes().length > 0 &&
         Invocation.class.isAssignableFrom(advice.getParameterTypes()[0]))
      {
         fillInvocationBody(invokeBody, advice, method);
      }
      else
      {
         fillThreadStackBody(invokeBody, advice, method);
      }
      invokeBody.append('}');
      CtMethod invoke = null;
      try
      {
         invoke = CtNewMethod.make(invokeBody.toString(), clazz);
      }
      catch(CannotCompileException e)
      {
         logger.error("Could not compile " + invokeBody);
         throw e;
      }
      invoke.setModifiers(javassist.Modifier.PUBLIC);
      clazz.addMethod(invoke);
      ProtectionDomain pd = aspect.getClass().getProtectionDomain();
      Class iclass = TransformerCommon.toClass(clazz, pd);

      Interceptor rtn = (Interceptor) iclass.newInstance();
      Field f = iclass.getField("aspectField");
      f.set(rtn, aspect);
      return rtn;
   }

   private static void fillThreadStackBody(StringBuffer invokeBody, Method advice, Method method) throws Exception
   {
      invokeBody.append("   org.jboss.aop.joinpoint.CurrentInvocation.push(invocation); ");
      invokeBody.append("   try {");
      invokeBody.append("return ($w)aspectField.").append(advice.getName());
      invokeBody.append("(");
      appendParamList(invokeBody, 0, advice.getParameterTypes(), method.getParameterTypes());
      invokeBody.append(");");
      invokeBody.append("   } finally { org.jboss.aop.joinpoint.CurrentInvocation.pop(); }");
   }

   private static void fillInvocationBody(StringBuffer invokeBody, Method advice, Method method)
   {
      invokeBody.append("   return ($w)aspectField.").append(advice.getName());
      invokeBody.append("(typedInvocation, ");
      appendParamList(invokeBody, 1, advice.getParameterTypes(), method.getParameterTypes());
      invokeBody.append(");");
   }
   
   /**
    * Appends the joinpoint parameter list to <code>code</code>.
    * 
    * @param code             buffer to where generated code is appended
    * @param offset           indicates from which advice parameter index are the
    *                         joinpoint parameters. All advice parameters that 
    *                         come before the <code>offset</code> stand for other
    *                         values, that are not joinpoint parameters.
    * @param adviceParams     list of advice parameter types
    * @param joinPointParams  list of joinpoint parameter types
    */
   private static void appendParamList(StringBuffer code, int offset, Class adviceParams[], Class[] joinPointParams)
   {
      if (adviceParams.length > 0)
      {
         int [] paramIndexes = new int[adviceParams.length];
         boolean[] assignedParams = new boolean[joinPointParams.length];
         for (int i = offset; i < adviceParams.length; i++)
         {
            int j;
            for (j = 0; j < joinPointParams.length; j++)
            {
               if (adviceParams[i].equals(joinPointParams[j]) && !assignedParams[j])
               {
                  break;
               }
            }
            // if didn't find the same type, look for supertypes
            if (j == joinPointParams.length)
            {
               for (j = 0; j < joinPointParams.length; j++)
               {
                  if (adviceParams[i].isAssignableFrom(joinPointParams[j]) && !assignedParams[j])
                     break;
               }
               // didn't find super types either
               if (j == joinPointParams.length)
                  throw new RuntimeException();
            }
            assignedParams[j] = true;
            paramIndexes[i] = j;
         }
         if (AspectManager.optimize)
         {
            code.append("typedInvocation.arg").append(paramIndexes[offset]);
            for (int i = offset + 1; i < paramIndexes.length; i++)
            {
               code.append(", typedInvocation.arg");
               code.append(paramIndexes[i]);
            }
         }
         else
         {
            code.append(ReflectToJavassist.castInvocationValueToTypeString(
                  adviceParams[offset],
                  "arguments[" + paramIndexes[offset] + "]"));
            for (int i = offset + 1; i < paramIndexes.length; i++)
            {
               code.append(", ");
               code.append(ReflectToJavassist.castInvocationValueToTypeString(
                     adviceParams[i],
                     "arguments[" + paramIndexes[i] + "]"));
            }
         }
      }
   }  
}