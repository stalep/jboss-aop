<chapter id="jdk14compatibility">
   <title>JDK 1.4 Backwards Compatibility</title>
   <para>
      Despite the fact that it has been a while since the release of JDK 5, there are projects
      that still require backwards compatibility with JDK 1.4. This is relatively common, and
      the reasons for it are diverse.
      To deal with this type of requirement, JBoss AOP provides two different solutions. By using
      one of them, you can use all features JBoss AOP provides, including annotation-related
      features, and still keep your code backwards compatible with JDK1.4.
   </para>
   <sect1 id="jdk14-jbossretro" revision="1">
      <title>JBoss Retro</title>
      <para>
         The first solution to achieve JDK 1.4 backwards compatibility is to use the JBoss Retro
         tool. JBoss Retro converts JDK 5 compiled bytecodes into bytecodes that can be
         run using a JDK 1.4 virtual machine.
      </para>
      <para>
         This tool acts as a bytecode processor, and using it is very simple. You just need to
         write your code using JDK 5 constructs and features, and then compile it,
         using JDK 5. Next, process the generated bytecodes using
         JBoss Retro tool (just like you do when you use aopc compiler), and now your
         bytecodes are ready to run using a JDK 1.4 virtual machine. Notice this solution
         allows not only the use of JBoss AOP annotations, but of most JDK 5 features and
         new API operations.
      </para>
      <para>
         The simplest way to run JBoss Retro is using the ant task. You just need to declare it:
      </para>
      <programlisting><![CDATA[<taskdef name="retro" classname="org.jboss.ant.tasks.retro.Retro" classpathref="jboss.retro.classpath"/>
      ]]></programlisting>
      <para>
         And use it as in the following example:
      </para>
      <programlisting><![CDATA[<retro compilerclasspathref="jboss.retro.classpath" destdir=".">
   <classpath refid="jboss.retro.classpath"/>
   <classpath path="."/>
   <src path="."/>
</retro>]]></programlisting>
      <para>
         <anchor id="jbossretroparam"/>
         This task takes the following parameters:
            <itemizedlist>
               <listitem>
                  <literal>compilerclasspathref</literal> -
                  This represent the jars needed for the JBoss Retro processor to work. The
                  <literal>compilerclasspath</literal> version takes the paths of the
                  jar files, and the
                  <literal>compilerclasspathref</literal> version takes the
                  name of a predefined ant path.
               </listitem>
               <listitem>
                  <literal>classpath</literal> or
                  <literal>classpathref</literal> - Path to the
                  compiled classes to be processed by JBoss Retro. The
                  <literal>classpath</literal>
                  version takes the path of the directory, and the
                  <literal>classpathref</literal>
                  version takes the name of a predefined ant path.
               </listitem>
               <listitem>
                  <literal>verbose</literal> - Default is false. If true, verbose output
                  is generated, which comes in handy for diagnosing unexpected results.
               </listitem>
               <listitem>
                  <literal>suppress</literal> - Default is true. If false, error messages
                  will not be suppressed.
               </listitem>
               <listitem>
                  <literal>maxmemory</literal> - Sets the maximum memory of the java task that will
                  be forked.
               </listitem>
               <listitem>
                  <literal>destdir</literal> - the dir where JBoss Retro will write the
                  resulting bytecodes.
               </listitem>
            </itemizedlist>
      </para>
      <para>It is also possible to run JBoss Retro with the following command line:</para>
      <programlisting>
   $ java -cp &lt;all the JBoss AOP jars and the directory containing files we want to AOP&gt; \
         -verbose &lt;true/false&gt; -suppress &lt;true/false&gt; -destdir &lt;
         org.jboss.ant.tasks.retro.Weaver \
         [-bytecode]&lt;files&gt;+
            </programlisting>
      <para>
         JBoss Retro is the de facto standard solution JBoss Group provides to achieve JDK 1.4 backward compatibility.
         However, if you do not have the option to compile your code using JDK 5, you should go with the next solution,
         the annotation compiler.
      </para>
   </sect1>
   <sect1 id="jdk14-anncompiler" revision="1">
      <title>JDK1.4 Annotation Compiler</title>
      <para>
         Unlike JBoss Retro, the annotation compiler does not support all JDK 5 constructs and new APIs.
         Its functionality consists in supporting only annotations, that must be written in the form of doclets.
         Nevertheless, this is enough to allow the use of all JBoss AOP features, and doesn't require a JDK 5
         compiler.
      </para>
      <para>
         This way, if you can't use a JDK 5 compiler to compile your code, you should stick with the annotation
         compiler. It will process your application's bytecodes, transforming doclets into annotations.
         The result of this transformation is that your doclets will become viewable by JBoss AOP as
         if they were regular JDK 5 annotations.
      </para>
      <para>
         In the next sections, we will see what is the format your doclets need to follow in order to be
         transformed into annotations, and how to use the annotation compiler.
      </para>
   </sect1>
      <sect2 id="annotationcompiler-annotations" revision="1">
         <title>Annotations with JDK 1.4.2</title>

         <para>
            In JDK 5, annotations must map to an annotation type, which is defined using the following syntax:

         <programlisting>
   package com.mypackage;

   public @interface MyAnnotation
   {
      String myString();
      int myInteger();
   }
            </programlisting>

            Similarly, annotations for use with the annotation compiler also need to map to
            a type. And this one is defined in exactly the same way as above, with the
            important difference that '@interface' is replaced by 'interface'. i.e.
            the simulated annotation type is a normal Java interface:
            <programlisting>
   package com.mypackage;

   public interface MyAnnotation extends org.jboss.lang.Annotation
   {
      String myString();
      int myInteger();
   }
            </programlisting>
         </para>

         <para>
            One difference from AOP 1.x is that the interfaces defining the annotations must now extend
            <literal>org.jboss.lang.Annotation</literal>, this is because JBoss Retro is now the primary
            mechanism for using annotations in JDK 1.4.
         </para>

         <para>
            The syntax for using annotations in JDK 1.4.2 is almost exactly the same as
            JDK 5 annotations except for these subtle differences:
            <itemizedlist>
               <listitem>they are embedded as doclet tags</listitem>
               <listitem>You use a double at sign, i.e. '@@'</listitem>
               <listitem>
                  You MUST have a space after the tag name otherwise you will get
                  a compilation error. (This is the quirkiness of the QDox doclet compiler
                  used to compile the annotations.')
               </listitem>
               <listitem>
                  You cannot import the annotation type, you must use the fully
                  qualified name of the interface.
               </listitem>
               <listitem>
                  You can only annotate top-level and inner classes, and their constructors, methods and fields.
                  Annotating anonyomus classes, local classes, and parameters for constructors or methods is not supported.
               </listitem>
               <listitem>You cannot specify default values for an annotation's value</listitem>
            </itemizedlist>
         </para>

         <para>
            This example shows an annotated class in JDK 1.4.2:
            <programlisting>
   package com.mypackage;

   /**
    * @@com.mypackage.MyAnnotation (myString="class", myInteger=5)
    */
   public class MyClass
   {
      /**
       * @@com.mypackage.MyAnnotation (myString="field", myInteger=4)
       */
      private String myField;

      /**
       * @@com.mypackage.MyAnnotation (myString="constructor", myInteger=3)
       */
      public MyClass()
      {
      }

      /**
       * @@com.mypackage.MyAnnotation (myString="method", myInteger=3)
       */
      public int myMethod()
      {
      }
   }
            </programlisting>
         </para>

         <para>
            The next aspect is the JDK1.4.2 version of the <link linkend="introductionEx">@Introduction
            exammple</link> (<xref linkend="annotated"/>). Notice the slight difference in the JDK 1.4.2 annotation: class
            values don't have the ".class" suffix:
         <programlisting>
   package com.mypackage;

   /*
    * @@org.jboss.aop.Aspect (scope = Scope.PER_VM)
    */
   public class IntroAspect
   {
      /*
       * @org.jboss.aop.Introduction (target=com.blah.SomeClass, \
             interfaces={java.io.Serializable})
       */
      public static Object pojoNoInterfacesIntro;
   }
         </programlisting>
         </para>
         <para>
         Now, look at the next example:
         <programlisting>
   package com.mypackage;

   import org.jboss.aop.introduction.AnnotationIntroduction;

   /**
    * @@org.jboss.aop.InterceptorDef (scope=org.jboss.aop.advice.Scope.PER_VM)
    * @@org.jboss.aop.Bind (pointcut="all(com.blah.SomePOJO)")
    */
   public class IntroducedAnnotationInterceptor implements Interceptor
   {
      /**
       * @@org.jboss.aop.AnnotationIntroductionDef \
             (expr="method(* com.blah.SomePOJO->annotationIntroductionMethod())", \
             invisible=false, \
             annotation="@com.mypackage.MyAnnotation \
             (string='hello', integer=5, bool=true)")
       */
      public static AnnotationIntroduction annotationIntroduction;

      public String getName()
      {
         return "IntroducedAnnotationInterceptor";
      }

      public Object invoke(Invocation invocation) throws Throwable
      {
         return invocation.invokeNext();
      }
   }
         </programlisting>
         The code above is the jdk1.4.2 version equivalent to the <link linkend="annotatIntroductEx">
            @AnnotationIntroductionDef example</link> we have seen in <xref linkend="annotated"/>.
         Note that, in the version above, the reference to only uses one '@'. In addition,the value for
            its string parameter uses single quotes instead of double ones.
      </para>

      </sect2>
      <sect2 id="annotationcompiler-enums" revision="1">
         <title>Enums in JDK 1.4.2</title>
         <para>
            Another JDK 5 feature that JBoss AOP helps introduce to JBoss 1.4.2 are Enums.
            As an example we can look at the
            <literal>org.jboss.aop.advice.Scope</literal>
            enum that is used for the
            <literal>@Aspect</literal> annotation. Here is the
            JDK 5 version.
            <programlisting>
            package org.jboss.aop.advice;

            public enum Scope
            {
               PER_VM, PER_CLASS, PER_INSTANCE, PER_JOINPOINT
            }
            </programlisting>

            And it's usage in JDK 5
            <programlisting>
   package com.mypackage;

   @Aspect (scope=org.jboss.aop.advice.Scope.PER_VM)
   public class SomeAspect
   {
   }
            </programlisting>
            The usage in JDK 1.4.2 is similar:
            <programlisting>
   package com.mypackage;

   /**
    * @@org.jboss.aop.Aspect (scope=org.jboss.aop.advice.Scope.PER_VM)
    */
   public class SomeAspect
   {
      //...
   }
            </programlisting>
            However the declaration of the enumeration is different in 1.4.2:
            <programlisting>
   package org.jboss.aop.advice;

   import java.io.ObjectStreamException;

   public class Scope extends org.jboss.lang.Enum
   {
      private Scope(String name, int v)
      {
         super(name, v);
      }

      public static final Scope PER_VM = new Scope("PER_VM", 0);
      public static final Scope PER_CLASS = new Scope("PER_CLASS", 1);
      public static final Scope PER_INSTANCE = new Scope("PER_INSTANCE", 2);
      public static final Scope PER_JOINPOINT = new Scope("PER_JOINPOINT", 3);

      private static final Scope[] values = {PER_VM, PER_CLASS, PER_INSTANCE, PER_JOINPOINT};

      Object readResolve() throws ObjectStreamException
      {
         return values[ordinal];
      }

   }
            </programlisting>
         </para>
         <para>
            To create your own enum class for use within annotations, you need to inherit
            from
            <literal>org.jboss.lang.Enum</literal>. Each enum has two values, a
            String name, and an integer ordinal. The value used for the ordinal must
            be the same as it's index in the static array.
         </para>
      </sect2>

      <sect2 id="annotationcompiler-nestedannotations" revision="1">
         <title>Using Annotations within Annotations</title>
         <para>
            The annotation compiler allows you to use annotations within annotations. This
            is best illustrated with an example. The definitions of the annotation
            interfaces in JDK 1.4.2:

            <programlisting>
            com.mypackage;

            public interface Outer
            {
               Inner[] values();
            }
            </programlisting>

            <programlisting>
            com.mypackage;

            public interface Inner
            {
               String str();
               int integer();
            }
            </programlisting>
         </para>
         <para>
            The annotations can be applied as follows
            <programlisting>
            com.mypackage;

            /**
             * @@com.mypackage.Outer ({@@com.mypackage.Inner (str="x", integer=1), \
                   @@com.mypackage.Inner (str="y", integer=2)})
             */
            public class Test
            {
               Inner[] values();
            }
            </programlisting>

         </para>
      </sect2>


      <sect2 id="annotationcompiler-compiler" revision="1">
         <title>Using the Annotation Compiler</title>
         <para>
            In order to use the JDK 1.4.2 annotations you have to precompile your
            files with an annotation compiler.
         </para>

         <para>
            To use the annotation compiler you can create a simple ant build.xml file

            <programlisting><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>

<project default="run" name="JBoss/AOP">
   <target name="prepare">]]></programlisting>
 Include the jars AOP depends on
            <programlisting><![CDATA[
      <path id="javassist.classpath">
         <pathelement path="../../../javassist.jar"/>
      </path>
      <path id="trove.classpath">
         <pathelement path="../../../trove.jar"/>
      </path>
      <path id="concurrent.classpath">
         <pathelement path="../../../concurrent.jar"/>
      </path>
      <path refid="jboss.common.core.classpath"/>
      <path refid="jboss.common.logging.spi.classpath"/>
      <path refid="jboss.common.logging.log4j.classpath"/>
      <path refid="jboss.common.logging.jdk.classpath"/>
         <pathelement path="../../../jboss-common.jar"/>
      </path>
      <path id="jboss.aop.classpath">
         <pathelement path="../../../jboss-aop.jar"/>
      </path>
      <path id="qdox.classpath">
         <pathelement path="../../../qdox.jar"/>
      </path>
      <path id="classpath">
         <path refid="javassist.classpath"/>
         <path refid="trove.classpath"/>
         <path refid="jboss.aop.classpath"/>
      <path refid="jboss.common.core.classpath"/>
      <path refid="jboss.common.logging.spi.classpath"/>
      <path refid="jboss.common.logging.log4j.classpath"/>
      <path refid="jboss.common.logging.jdk.classpath"/>
         <path refid="concurrent.classpath"/>
         <path refid="qdox.classpath"/>
      </path>]]></programlisting>
            Define the ant task that does the annnotation compilation
            <programlisting><![CDATA[
      <taskdef
         name="annotationc"
         classname="org.jboss.aop.ant.AnnotationC"
         classpathref="jboss.aop.classpath"/>
   </target>

   <target name="compile" depends="prepare">]></programlisting>
         Compile the source files
         <programlisting><!CDATA[
      <javac srcdir="."
         destdir="."
         debug="on"
         deprecation="on"
         optimize="off"
         includes="**">
            <classpath refid="classpath"/>
      </javac>]]></programlisting>
            Run the annotation compiler
            <programlisting><![CDATA[
      <annotationc compilerclasspathref="classpath" classpath="." bytecode="true">
         <src path="."/>
      </annotationc>
   </target>
</project>]]></programlisting>
         </para>

         <para>
            The
            <literal>org.jboss.aop.ant.AnnotationC</literal> ant task takes several parameters.

            <itemizedlist>
               <listitem>
                  <literal>compilerclasspath</literal>,
                  <literal>compilerclasspathref</literal>,
                  <literal>classpath</literal>,
                  <literal>classpathref</literal> and
                  <literal>verbose</literal> -
                  These have the same meaning as in the <link linkend="jbossretroparam">JBoss Retro task</link>.
                  <!--These are interchangable, and represent the jars needed for the annotation compiler
                  to work. The
                  <literal>compilerclasspath</literal> version takes the paths of the
                  jar files, and the
                  <literal>compilerclasspathref</literal> version takes the
                  name of a predefined ant path.-->
               </listitem>
               <listitem>
                  <literal>bytecode</literal> - The default is false. If true the annotation compiler
                  instruments (i.e. modifies) the class files with the annotations. In this case,
                  the classes must be precompiled with javac and
                  <literal>classpath</literal> or
                  <literal>classpathref</literal> must be specified.
               </listitem>
               <!--<listitem>
                  <literal>classpath</literal> or
                  <literal>classpathref</literal> - Path to the
                  compiled classes to be instrumented with annotations, if
                  <literal>bytecode</literal>="true". The
                  <literal>classpath</literal>
                  version takes the path of the directory, and the
                  <literal>classpathref</literal>
                  version takes the name of a predefined ant path.
               </listitem> -->
               <listitem>
                  <literal>xml</literal> - Default is false. If true an xml file is generated
                  containing information of how to attach the annotations at a later stage in
                  the aop process.
               </listitem>
               <listitem>
                  <literal>output</literal> - If
                  <literal>xml</literal>="true", this lets
                  you specify the name you would like for the generated xml file. The default
                  name is
                  <literal>metadata-aop.xml</literal>
               </listitem>
<!--               <listitem>
                  <literal>verbose</literal> - Default is false. If true, verbose output
                  is generated, which comes in handy for diagnosing unexpected results.
               </listitem>-->
            </itemizedlist>
            You cannot currently specify both
            <literal>bytecode</literal> and
            <literal>xml</literal>.
         </para>
         <para>
            You can also run
            <literal>org.jboss.aop.ant.AnnotationC</literal> from the command line, you need
            <programlisting>
   $ java -cp &lt;all the JBoss AOP jars and the directory containing files we want to AOP&gt; \
         org.jboss.aop.annotation.compiler.AnnotationCompiler \
         [-xml [-o outputfile ]] [-bytecode]&lt;files&gt;+
            </programlisting>
         </para>
         <para>
            In the /bin folder of the distribution we have provided batch/script files to make
            this easier. It includes all the aop libs for you, so you just have to worry
            about your files. The usage is:
            <programlisting>
   $ annotationc &lt;classpath&gt; [-verbose] [-xml [-o outputfile]] [-bytecode] &lt;dir_or_file&gt;+
            </programlisting>
         </para>
         <para>
            <itemizedlist>
               <listitem>
                  <literal>classpath</literal> - path to your classes and any jars your code depends on
               </listitem>
            </itemizedlist>
            The other parameters are the same as above.
         </para>
      </sect2>
</chapter>

