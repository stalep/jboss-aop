!!!Before and After Advices

!!Overview
JBoss AOP provides several types of advices. The advices seen on the previous
section, as well as JBoss AOP interceptors, provide around join point interception.
In this example we introduce before and after advices, and compare their roles to
around advices' role.

!!Writing Before/After Advices

Before and after advices are lightweight advices when compared to around advices.
JBoss AOP invokes these advices before or after the joinpoint execution.

As we will see in the next [example|../annotated-parameters/annotated-parameters.html],
these advices can have several different signatures. However, in our
first example, we will use signatures that are closest to what has been shown on
previous examples.
   
So, we introduce a before and after advices as being of the form:

{{{
public void <any-method-name>(@JoinPoint <any Joinpoint type>)
}}}

Differently from around advices and interceptors, throwing a {{Throwable}} is
not necessary, because these advices do not wrap a joinpoint.

Instead of {{Invocation}} instances, before/after advices receive instances
of [{{org.jboss.aop.IJoinpointInfo}} and subinterfaces|../../misc/joinpoint.html]
as parameters.

Furthermore, one can notice the presence of the parameter annotation {{@org.jboss.aop.advice.annotation.JoinPoint}}. This is necessary because
before/after advices can receive values with several semantic roles as parameters.
As we will see [next|../annotated-parameters/annotated-parameters.html],
this annotation is used to distinguish this parameter type from the other ones, so we 
can achieve flexibility on the type, order and presence of advice parameters.

!!Binding Before/After Advices

To bind a before/after advice to a pointcut, you only need to declare an xml binding as
follows (open up {{jboss-aop.xml}} to see this example):

{{{
<bind pointcut="execution(public void $instanceof{Transaction}->run())">
      <before name="beforeAdvice" aspect="mypackage.MutexAspect"/>
      <after name="afterAdvice" aspect="mypackage.MutexAspect"/>
</bind>
}}}

As you can see, you just need to declare a usual bind tag, and add to it 
{{<before>}} and {{<after>}} tags for before and after advices
respectively. We can also mix interceptor declarations and around, before, and
after advices declarations in a single binding.

   
!!Around, Before and After Advices

As seen on previous sections, around advices wrap the joinpoint execution. An around
advice replaces the joinpoint execution in the base system, and is responsible for
forwarding execution to the joinpoint itself, as well as for returning a value to the
base system.

Around advices can be composed by four parts at most: a before joinpoint execution
block, a proceed to joinpoint step, an after joinpoint execution block, and, finally,
a return value step. To see an example, consider this {{PER_VM}} scoped aspect:

{{{
public class SynchronizationAspect
{
   public Object aroundAdvice(Invocation invocation) throws Throwable
   {
      Object result;

      // part 1: retrive lock before joinpoint execution
      synchronized(this)
      {
         System.out.println(">>> Retrieved concurrency lock");

         // part 2: proceed to joinpoint execution
         result = invocation.invokeNext();

      // part 3: release lock after joinpoint execution
         System.out.println("<<< Releasing concurrency lock");
      }

      // part 4: return result
      return result;
   }
}
}}}

{{SynchronizationAspect}} synchronizes all intercepted joinpoints (in a
concurrent programming application), avoiding that two or more intercepted joinpoints
run at the same time.

As we can see, {{SynchronizationAspect.aroundAdvice()}} is composed of four
steps:

* retrieving a lock before the joinpoint execution, achieved by entering the {{synchronized}} block;
* proceeding to joinpoint execution;
* releasing the lock after the joinpoint execution, achieved by exiting the {{synchronized}} block;
* and returning the joinpoint result.

Notice that this advice does not alter joinpoint execution (the advice does not
skip it) nor its return result (the advice could overwrite this value, but returns
the joinpoint return value itself instead). Hence, we can say that the relevant part
of it is only what is performed before and after the joinpoint (parts 1 and 3). To
illustrate the before/after concept, we wish to replace this single around advice
by a couple of before/after advices. However, we cannot do that by using the
previous example. A synchronized block cannot be splitten into two parts and still
achieve the same effect. So, lets first replace this around advice by one that uses a
mutex intead of a synchronized block:

{{{
public class MutexAspect
{
   private Object lock = new Object();
   private boolean locked = false;   
   
   public Object aroundAdvice(Invocation invocation) throws Throwable
   {
      Object result;

      // part 1: retrive lock before joinpoint execution
      synchronized(lock)
      {
         while (locked)
         {
            try
            {
               lock.wait();
            }
            catch(InterruptedException e)
            {
               Thread.currentThread().interrupt();
               return; 
            }
         }
         locked = true;
         System.out.println(">>> Retrieved concurrency lock");
      }

      // part 2: proceed to joinpoint execution
      result = invocation.invokeNext();

      // part 3: release lock after joinpoint execution
      synchronized(lock)
      {
         locked = false;
         lock.notify();
         System.out.println("<<< Releasing concurrency lock");
      }

      // part 4: return result
      return result;
   }
}
}}}

As much as {{SynchronizedAspect}}, {{MutexAspect}} avoids simultaneous
access to the intercepted joinpoint, and is also composed of the four steps
(getting a lock, proceeding to joinpoint execution and releasing the lock).

Now we can easily split this around advice into two advices: one that retrieves
the lock, and another one that releases it. We wish to run the first one before a
joinpoint, and the other one, after it.

The example that follows is a copy of the previous one, except that, now, {{MutexAspect.aroundAdvice()}} has been splitten into {{MutexAspect.beforeAdvice()
}} and {{MutexAspect.afterAdvice()}}:

{{{
public class MutexAspect
{
   private Object lock = new Object();
   private boolean locked = false;   
   
   public void beforeAdvice(@JoinPoint Joinpoint joinPoint)
   {
      synchronized(lock)
      {
         while (locked)
         {
            try
            {
               lock.wait();
            }
            catch(InterruptedException e)
            {
               Thread.currentThread().interrupt();
               return; 
            }
         }
         locked = true;
         System.out.println(">>> Retrieved concurrency lock");
      }
   }
   
   public void afterAdvice(@JoinPoint Joinpoint joinPoint)
   {
      synchronized(lock)
      {
         locked = false;
         lock.notify();
         System.out.println("<<< Releasing concurrency lock");
      }
   }
}
}}}         

Notice that, in this version, parts 2 and 4 are gone (proceeding to joinpoint
execution and returning its result). This is due to the fact that before and after
advices don't wrap a joinpoint, they are just executed before or after it.

!!Around vs Before/After

As is shown in this example, around advices can generally be broken into two related
before and after advices. The reverse is also true.
However, there are some subtleties that can help you to choose one form or the
other.

First of all, these are features that are available only to around advices:

* capability of replacing the entire joinpoint execution, by skipping the call to {{Invocation.invokeNext() method}};
* capability of skipping the invocation of subsequent around advices and interceptors, by calling {{Invocation.invokeTarget()}} instead of {{Invocation.invokeNext()}};
* addition of meta-data, available on Invocation objects only.

When you need one of those advanced features, you should use an around advice or
interceptor. Besides, there are aspects that cannot be implemented as a
pair of before and after advices. An example would be the {{SynchronizedAspect}}
shown before. A synchronized block cannot be broken into two blocks and achieve the
same result as one single synchronized block. In the example, we wrote a similar,
more complex aspect to illustrate the before/after advice concept. In real
applications, however, this aspect would not be replaced by a more complex one,
unless this could bring advantages to the application.

On the other hand, before and after advices also provide some advantages. A pair of
related before/after advices:

* is lightweight, when compared to around advices
* can be bound to different joinpoints. The before advice can be invoked before joinpoint A and the after advice, after joinPoint B

Since they are more lighweight, prefer using a pair of before/after advices, unless
you have a reason to do otherwise.
Regarding the second item in the list, it can be extremely useful in the case of
MutexAspect. Instead of controling the multi-threaded access to a single joinpoint,
we could obtain the lock before a joinpoint, and release it later, after a different
joinpoint execution. This allows the synchronization of a sequence of joinpoints as
if they were a single unit.

Lets remark that replacing the joinpoint return value is not a feature exclusive to around
advices and interceptors. An after advice can also return a value (for more on this,
refer to the [Return Types|../return-types/return-types.html] example).

!!Unrelated Before and After Advices

Despite the application of before and after advices shown in this example, these
advices can also be used in an unrelated, independent manner.

An aspect whose code needs to run only before the joinpoint execution should contain
only before advices. The same applies to an aspect that needs to execute after
a joinpoint execution, regarding after advices. Furthermore, an aspect that provides
functionalities that need to be run before a joinpoint execution, and functionalities
that need to be run after, should contain a mix of unrelated before and after advices.

Examples of unrelated before and after advices will be shown in the next examples of
this tutorial.

!!Applying MutexAspect

In our example, we apply {{MutexAspect}} to a classic example of synchronization
and concurrent programming application.

Suppose you have bank accounts and operations on accounts can be performed
concurrently. If we don't synchronize those operations we can end up with an invalid
account balance.

An example would be two operations on account {{A}}. Suppose one of them
is a deposit of $30.00, while the other one is a withdrawal of $10.00. If these
operations are run in an unsynchronized manner, like follows:

* deposit: read balance: $50.00
* withdrawal: read balance: $50.00
* deposit: add $30.00
* withdrawal: subtract $10.00
* deposit: write final balance of $80.00
* withdrawal: write final balance of $40.00

The final balance of the account would be $40.00, and the deposit of $50.00 would
have been completely ignored, since its final balance has been overwritten by 
the withdrawal operation.

!!Running

__THIS EXAMPLE REQUIRES JDK 1.5!!__ To compile and run:
{{{
  $ ant
}}}
It will javac the files and then run the AOPC precompiler to manipulate the bytecode, then finally run the example.  The output should be similar to this:
{{{
run:
     [java] SETUP
     [java] =====
     [java] Creating account 'A' with initial balance of $30.0
     [java] Creating account 'B' with initial balance of $50.0
     [java] Creating account 'C' with initial balance of $0.0
   
     [java] TRANSACTIONS
     [java] ============
     [java] Using context classloader sun.misc.Launcher$AppClassLoader@133056f to load aspect mypackage.MutexAspect
     [java] Using context classloader sun.misc.Launcher$AppClassLoader@133056f to load aspect mypackage.MutexAspect
     [java] >>> Retrieved concurrency lock
     [java] Depositing US$ 50.00 to account A
     [java] <<< Releasing concurrency lock
     [java] >>> Retrieved concurrency lock
     [java] Transfering US$ 100.00 from account B to account C
     [java] <<< Releasing concurrency lock
     [java] >>> Retrieved concurrency lock
     [java] Withdrawing US$ 10.00 from account A
     [java] <<< Releasing concurrency lock
     [java] >>> Retrieved concurrency lock
     [java] Transfering US$ 89.11 from account C to account A
     [java] <<< Releasing concurrency lock
     [java] >>> Retrieved concurrency lock
     [java] Depositing US$ 51.00 to account B
     [java] <<< Releasing concurrency lock
     [java] >>> Retrieved concurrency lock
     [java] Withdrawing US$ 0.11 from account C
     [java] <<< Releasing concurrency lock
     [java] >>> Retrieved concurrency lock
     [java] Withdrawing US$ 5.00 from account B
     [java] <<< Releasing concurrency lock

     [java] FINAL BALANCE
     [java] ===== =======
     [java] A: US$ 159.11
     [java] C: US$ 10.78
     [java] B: -US$ 4.00

}}}

You can add accounts and transactions to this example application by editing the
{{input.txt}} file.
